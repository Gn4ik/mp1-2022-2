#define _CRT_SECURE_NO_WARNINGS //подтверждаем, что готовы использовать не очень безопасную функцию scanf()
#include <locale.h> // локализация
#include <stdio.h> // обязательная часть каждой программы с вводом-выводом
#include <math.h> // математические операции

void main() {
	int n, questionNumber, n1, n2, n3, n4 ,n5, correct, tryNumber, cows, bulls, allMatches, gameIsOn, catched; /* длина загаданного числа; цифры разрядов загаданного числа;
	переменная, отвечающая за несовпадение цифр в числе; попытка пользователя; коровы; быки; просто совпадения(коровы + быки); переменная, отвечающая за то, идет ли игра, проверка, пойманы ли животные */  

	char name[] = ""; // переменная имени пользователя - строка, а строка - есть массив символов.
	n1 = 10;
	n2 = 10;
	n3 = 10;
	n4 = 10;
	n5 = 10;
	correct = 0;
	cows = 0;
	bulls = 0;
	questionNumber = 0;
	tryNumber = 0;
	allMatches = 0;
	gameIsOn = 1;
	catched = 0;

	setlocale(LC_ALL, "Russian"); // локализация

	printf("Добрый день! Хотя, не очень добрый...\n Из лаборатории сбежало стадо цифрового рогатого скота! Требуется помощь квалифицированных кибер-пастухов.\n Вы в деле? Введите свое имя на английском языке:\n");
	scanf("%s", &name); // ввод имени
	/// <summary>
	/// .
	/// </summary>
	printf("Дорогой %s, на Вас вся надежда! Выберите размер стада (длину числа от 2 до 5 строго)\n", name);
	scanf("%i", &n);

	n1 = abs(srand() % 9) + 1; // первая цифра загаданного числа (обязательно не ноль!)
	questionNumber = n1 * pow(10, n - 1);

	if (n == 2) { // условия под каждую n. Конечно, можно реализовать программу короче с помощью массива, но это рабочий интересный метод абсолютно без использования массивов)
		while (correct == 0) { // correct == 0 - первые 2 числа совпадают. correct == 1 - числа не совпадают, можно двигаться дальше 
			n2 = abs(rand() % 10); 
			if (n2 != n1) {
				correct = 1;
			}
		}
		questionNumber += n2; // прибавляем к разряду единиц второе число
	}
	if (n == 3){ // алгоритм сходен с прошлым, но добавляется еще одно условие - третье число не равно как второму, так и первому
		while (correct == 0) {
			n2 = abs(rand() % 10);
			if (n2 != n1) {
				correct = 1;
			}
		}
		questionNumber += n2 * 10; // естественно, второе число умножаем на 10 перед прибавлением (потому что + разряд)
		correct = 0;

		while (correct == 0) {
			n3 = abs(rand() % 10);
			if (n3 != n1 && n3 != n2) {
				correct = 1;
			}
		}
		questionNumber += n3;
		correct = 0;
	}

	if (n == 4) { // и т.д.
		while (correct == 0) {
			n2 = abs(rand() % 10);
			if (n2 != n1) {
				correct = 1;
			}
		}
		questionNumber += n2 * 100;
		correct = 0;

		while (correct == 0) {
			n3 = abs(rand() % 10);
			if (n3 != n1 && n3 != n2) {
				correct = 1;
			}
		}
		questionNumber += n3 * 10;
		correct = 0;

		while (correct == 0) { // и т.п.
			n4 = abs(rand() % 10);
			if (n4 != n1 && n4 != n2 && n4 != n3) {
				correct = 1;
			}
		}
		questionNumber += n4;
		correct = 0;
	}

	if (n == 5) { // много копировать. Но без массивов!
		while (correct == 0) {
			n2 = abs(rand() % 10);
			if (n2 != n1) {
				correct = 1;
			}
		}
		questionNumber += n2 * 1000;
		correct = 0;

		while (correct == 0) {
			n3 = abs(rand() % 10);
			if (n3 != n1 && n3 != n2) {
				correct = 1;
			}
		}
		questionNumber += n3 * 100;
		correct = 0;

		while (correct == 0) {
			n4 = abs(rand() % 10);
			if (n4 != n1 && n4 != n2 && n4 != n3) {
				correct = 1;
			}
		}
		questionNumber += n4 * 10;
		correct = 0;

		while (correct == 0) {
			n5 = abs(rand() % 10);
			if (n5 != n1 && n5 != n2 && n5 != n3 && n5 != n4) {
				correct = 1;
			}
		}
		questionNumber += n5;
		correct = 0;
	}


	while (gameIsOn != 0) { // пока статус игры не равен нулю, игра идет

		allMatches = 0; // каждый раз обновляем кол-во общих совпадений и быков
		bulls = 0;

		printf("Введите предполгаемое число, чтобы узнать количество быков и коров в сбежавшем стаде:\n\n");
		scanf("%i", &tryNumber);

		for (int i = 0; i < n; i++) { // Все совпадения: вложенные циклы нужны для проверки всего и вся: сравнение каждой цифры одного числа с каждой цифрой другого
			for (int j = 0; j < n; j++) {
				if ((int)(tryNumber / pow(10, n - i - 1)) % 10 == ((int)(questionNumber / pow(10, n - 1 - j)) % 10)) { // пришлось помучиться, чтобы представить, как извлечь каждую цифру без индексов и массивов
					allMatches += 1;
				}
			}
		}

		for (int i = 0; i < n; i++) { // Вычисление количества быков. Тут, конечно, гораздо меньше проходов
			if ((int)(tryNumber / pow(10, n - i - 1)) % 10 == ((int)(questionNumber / pow(10, n - 1 - i)) % 10)) {
				bulls += 1;
			}
		}

		cows = allMatches - bulls; // только коров вычислять сложно. Додумался вычесть из всех совпадений быков и получил коров. Магия!

		printf("Состав потерянного стада: Быки - %i, Коровы - %i\n\n", bulls, cows);
		if (bulls == n){ // если кол-во быков равно длине числа - стадо поймано! Игра завершена
			catched = 1;
			break;
		}
		printf("Будете пытаться собрать стадо или пустите потерявшихся бедных животных на произвол судьбы? (любое число или 0)\n");
		scanf("%i", &gameIsOn);

	}
	if (catched != 0){ // условие, выводящее разные реплики в зависимости от результата ловли рогатых
		printf("Прекрасная работа! Животные собраны, сыты, одеты, обещали больше не сбегать!\n");
	}
	else{
		printf("Потерявшиеся цифровые быки и коровы были скормлены таким же цифровым волкам :(\n");
		printf("Загаданный код стада: %i\n", questionNumber);
	}
	

	system("PAUSE");
}